<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>findkeys(decode)安全实验 | HxChimenGのblog</title><link rel="icon" type="image/x-icon" href="../../../../favicon.ico"><link rel="preload" as="font" crossorigin="anonymous" href="../../../../font/Bender.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="../../../../font/BenderLight.ttf"><link rel="preload" as="font" crossorigin="anonymous" href="../../../../font/JetBrainsMono-Regular.woff2"><link rel="stylesheet" href="../../../../css/arknights.css"><style>@font-face {
  font-family: Bender;
  src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
  font-family: BenderLight;
  src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
  font-family: 'JetBrains Mono';
  src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
</style><script>var config = {"root":"/","code_fold":15,"search":{"preload":false,"activeHolder":"Enter here","blurHolder":"Search","noResult":"Data \"$0\" not found"},"code":{"codeInfo":"$0 - $1 lines","copy":"copy"}}</script><link type="text/css" rel="stylesheet" href="../../../../lib/encrypt/hbe.style.css"><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="../../../../lib/fontawesome/css/all.min.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.woff2") format('woff2');
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
 --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
 --light-background: url('../../../../img/bk.jpg');
 --theme-encrypt-confirm: 'confirm'
}</style><script defer src="../../../../js/arknights.js"></script><script defer src="../../../../js/search.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script defer type="module">import mermaid from '//unpkg.com/mermaid@10.5.0/dist/mermaid.esm.mjs';
window.mermaid = mermaid;
code.paintMermaid();
</script><script async src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script async src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script async src="../../../../lib/encrypt/hbe.js"></script><script async src="../../../../js/pjax.js"></script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax','.busuanzi'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);document.addEventListener('pjax:success', _ => bszCaller.fetch(
 "//busuanzi.ibruce.info/busuanzi?jsonpCallback=BusuanziCallback", a => {
  bszTag.texts(a),
  bszTag.shows()
}));reset()})</script><script class="pjax-js">reset= () => {document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="Search" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup" tabindex="0"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="../../../../"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="../../../../archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="../../../../CTF/"><span class="navItemTitle">CTF</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>findkeys(decode)安全实验</h1><div id="post-info"><span>First Post: <div class="control"><time datetime="2025-03-21T14:39:21.000Z" id="date"> 2025-03-21</time></div></span><br><span>Last Update: <div class="control"><time datetime="2025-03-21T15:01:22.533Z" id="updated"> 2025-03-21</time></div></span><br><span id="busuanzi_container_page_pv">Page View: <span class="control" id="busuanzi_value_page_pv">loading...</span></span></div></div><hr><div id="post-content"><h1 id="安全项目findkeys（decode）"><a href="#安全项目findkeys（decode）" class="headerlink" title="安全项目findkeys（decode）"></a>安全项目findkeys（decode）</h1><h2 id="项目要求"><a href="#项目要求" class="headerlink" title="项目要求"></a>项目要求</h2><p>主要目的：解码消息并找到密钥key1，key2，key3，key4的值，以下操作均在64位架构下进行<br>（x86架构下会有不同结果也会附到后面）</p>
<h1 id="1-找到key12"><a href="#1-找到key12" class="headerlink" title="1. 找到key12"></a>1. 找到key12</h1><h3 id="‘From：’从哪来？"><a href="#‘From：’从哪来？" class="headerlink" title="‘From：’从哪来？"></a>‘From：’从哪来？</h3><p>提示中告诉我们先找key1 key2：attack the keys in two independent parts. Try to break the first two keys first. </p>
<p>并且告诉我们如果key1key2正确 得到的对应结果前面会出现From:    （If you get the first and second keys right, a message that starts with From: will appear. ）</p>
<p>根据建议，先找key12的值，先看process_key12和extract_message12，前者是对我们即将传入的密钥值进行的操作，后者extract_message12通过读代码不难发现其实就是解密函数，而data就是密文</p>
<p>data值如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> data[] = &#123;       <span class="hljs-comment">//数据 密文</span><br><span class="hljs-number">0x63636363</span>, <span class="hljs-number">0x63636363</span>, <span class="hljs-number">0x72464663</span>, <span class="hljs-number">0x6F6D6F72</span>,<br><span class="hljs-number">0x466D203A</span>, <span class="hljs-number">0x65693A72</span>, <span class="hljs-number">0x43646E20</span>, <span class="hljs-number">0x6F54540A</span>,<br><span class="hljs-number">0x5920453A</span>, <span class="hljs-number">0x54756F0A</span>, <span class="hljs-number">0x6F6F470A</span>, <span class="hljs-number">0x21643A6F</span>,<br><span class="hljs-number">0x594E2020</span>, <span class="hljs-number">0x206F776F</span>, <span class="hljs-number">0x79727574</span>, <span class="hljs-number">0x4563200A</span>,<br><span class="hljs-number">0x6F786F68</span>, <span class="hljs-number">0x6E696373</span>, <span class="hljs-number">0x6C206765</span>, <span class="hljs-number">0x796C656B</span>,<br><span class="hljs-number">0x2C336573</span>, <span class="hljs-number">0x7420346E</span>, <span class="hljs-number">0x20216F74</span>, <span class="hljs-number">0x726F5966</span>,<br><span class="hljs-number">0x7565636F</span>, <span class="hljs-number">0x20206120</span>, <span class="hljs-number">0x6C616763</span>, <span class="hljs-number">0x74206C6F</span>,<br><span class="hljs-number">0x20206F74</span>, <span class="hljs-number">0x74786565</span>, <span class="hljs-number">0x65617276</span>, <span class="hljs-number">0x32727463</span>,<br><span class="hljs-number">0x6E617920</span>, <span class="hljs-number">0x680A6474</span>, <span class="hljs-number">0x6F697661</span>, <span class="hljs-number">0x20646E69</span>,<br><span class="hljs-number">0x21687467</span>, <span class="hljs-number">0x63002065</span>, <span class="hljs-number">0x6C6C7861</span>, <span class="hljs-number">0x78742078</span>,<br><span class="hljs-number">0x6578206F</span>, <span class="hljs-number">0x72747878</span>, <span class="hljs-number">0x78636178</span>, <span class="hljs-number">0x00783174</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<pre><code>    可以看出它是多个8位16进制数组合的数组，8位十六进制刚好是32位，也就是4字节（int类型）。想要得出具有有意义的内容，不难想到16进制转字符串，一个字符（char类型）1字节对应两个16进制数字，于是我们将去掉0x前缀和逗号的内容粘贴到转换网站里
</code></pre>
<p>6363636363636363724646636F6D6F72466D203A65693A7243646E206F54540A5920453A54756F0A6F6F470A21643A6F594E2020206F776F797275744563200A6F786F686E6963736C206765796C656B2C3365737420346E20216F74726F59667565636F202061206C61676374206C6F20206F747478656565617276327274636E617920680A64746F69766120646E6921687467630020656C6C7861787420786578206F727478787863617800783174</p>
<p class='item-img' data-src='image.png'><img src="image.png" alt="image.png"></p>
<pre><code> 然而通过后面的解码函数extract_message12的解码逻辑（指定方式的顺序读入message来生成明文）看，以上转换是无法得出正确的转换结果的，因为其中含有无法正常阅读的符号
</code></pre>
<p>   🤔那么问题出现在哪里呢，我们以0x72464663举例 ，7是最高位，3是最低位，观察内存可以发现这串数在内存中的存储方式是  63 46 46 72（内存的单位是字节，两个16进制一组），这叫做小端顺序，即低位地址在地址的低位（地址是从低到高看，前低后高）</p>
<p class='item-img' data-src='image%201.png'><img src="image%201.png" alt="image.png"></p>
<pre><code>   所以data的读取方式应该是每组数以两个数为单位从后向前读，也就是0x72 46 46 63，                     应该以63 46 46 72的顺序转换，所以自己写一个对应的解码程序,以下是正确结果
</code></pre>
<p class='item-img' data-src='image%202.png'><img src="image%202.png" alt="image.png"></p>
<p>转换代码如下（其实是gpt写的😋）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">hex_to_string</span><span class="hljs-params">(<span class="hljs-type">int</span> *data, <span class="hljs-type">size_t</span> len, <span class="hljs-type">char</span> *output)</span> &#123;<br>    <span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-comment">// 按小端顺序处理32位数据中的每个字节</span><br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte1 = (data[i] &amp; <span class="hljs-number">0xFF</span>);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte2 = ((data[i] &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte3 = ((data[i] &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> byte4 = ((data[i] &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xFF</span>);<br>        <br>        <span class="hljs-comment">// 存储每个字节到output字符串</span><br>        output[j++] = byte1;<br>        output[j++] = byte2;<br>        output[j++] = byte3;<br>        output[j++] = byte4;<br>    &#125;<br>    output[j] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 添加字符串结束符</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> data[] = &#123;  <span class="hljs-comment">// 数据 密文</span><br>        <span class="hljs-number">0x63636363</span>, <span class="hljs-number">0x63636363</span>, <span class="hljs-number">0x72464663</span>, <span class="hljs-number">0x6F6D6F72</span>,<br>        <span class="hljs-number">0x466D203A</span>, <span class="hljs-number">0x65693A72</span>, <span class="hljs-number">0x43646E20</span>, <span class="hljs-number">0x6F54540A</span>,<br>        <span class="hljs-number">0x5920453A</span>, <span class="hljs-number">0x54756F0A</span>, <span class="hljs-number">0x6F6F470A</span>, <span class="hljs-number">0x21643A6F</span>,<br>        <span class="hljs-number">0x594E2020</span>, <span class="hljs-number">0x206F776F</span>, <span class="hljs-number">0x79727574</span>, <span class="hljs-number">0x4563200A</span>,<br>        <span class="hljs-number">0x6F786F68</span>, <span class="hljs-number">0x6E696373</span>, <span class="hljs-number">0x6C206765</span>, <span class="hljs-number">0x796C656B</span>,<br>        <span class="hljs-number">0x2C336573</span>, <span class="hljs-number">0x7420346E</span>, <span class="hljs-number">0x20216F74</span>, <span class="hljs-number">0x726F5966</span>,<br>        <span class="hljs-number">0x7565636F</span>, <span class="hljs-number">0x20206120</span>, <span class="hljs-number">0x6C616763</span>, <span class="hljs-number">0x74206C6F</span>,<br>        <span class="hljs-number">0x20206F74</span>, <span class="hljs-number">0x74786565</span>, <span class="hljs-number">0x65617276</span>, <span class="hljs-number">0x32727463</span>,<br>        <span class="hljs-number">0x6E617920</span>, <span class="hljs-number">0x680A6474</span>, <span class="hljs-number">0x6F697661</span>, <span class="hljs-number">0x20646E69</span>,<br>        <span class="hljs-number">0x21687467</span>, <span class="hljs-number">0x63002065</span>, <span class="hljs-number">0x6C6C7861</span>, <span class="hljs-number">0x78742078</span>,<br>        <span class="hljs-number">0x6578206F</span>, <span class="hljs-number">0x72747878</span>, <span class="hljs-number">0x78636178</span>, <span class="hljs-number">0x00783174</span><br>    &#125;;<br>    <br>    <span class="hljs-type">size_t</span> len = <span class="hljs-keyword">sizeof</span>(data) / <span class="hljs-keyword">sizeof</span>(data[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 密文数据的元素数量</span><br>    <span class="hljs-type">char</span> output[len * <span class="hljs-number">4</span> + <span class="hljs-number">1</span>];  <span class="hljs-comment">// 存储转换后的字符串</span><br>    <br>    hex_to_string(data, len, output);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;转换后的字符串:\n%s\n&quot;</span>, output);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code> 除了自己敲代码转换之外 ，我们可以以一种简单方式直接找到转换后的结果
</code></pre>
<p>我们可以直接打断点在程序内调试 在内存中查看&amp;data的值，内存中本来就是小端顺序 所以内存右侧就是正确的转换结果</p>
<p class='item-img' data-src='image%203.png'><img src="image%203.png" alt="image.png"></p>
<pre><code>右侧就是vs自动帮我们转换的对应结果，截取放大如下
</code></pre>
<p class='item-img' data-src='image%204.png'><img src="image%204.png" alt="image.png"></p>
<h3 id="如何读出明文并找到key值🤔"><a href="#如何读出明文并找到key值🤔" class="headerlink" title="如何读出明文并找到key值🤔"></a>如何读出明文并找到key值🤔</h3><p>通过提示“如果你正确地获取了第一个和第二个键， 将显示一条以 From： 开头的消息”</p>
<p>而extract_message1函数经过观察就是对data进行转换的解密函数，它的运行需要两个参数</p>
<p>start（起点）和stride（步长），而这两个参数又是通过dummy变量赋值的</p>
<p>解码函数代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"> <br> <br><span class="hljs-type">char</span>* <span class="hljs-title function_">extract_message1</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> stride)</span> &#123;<br>	<span class="hljs-type">int</span> i, j, k;<br>	<span class="hljs-type">int</span> done = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = start + <span class="hljs-number">1</span>; !done; j++) &#123;         <br>		<span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; stride; k++, j++, i++) &#123;<br><br>			<span class="hljs-keyword">if</span> (*(((<span class="hljs-type">char</span>*)data) + j) == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;  <br>				done = <span class="hljs-number">1</span>;<br>				<span class="hljs-keyword">break</span>;<br>			&#125;<br><br>			message[i] = *(((<span class="hljs-type">char</span>*)data) + j);<br>		&#125;<br>	&#125;<br>	message[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>	<span class="hljs-keyword">return</span> message;<br>&#125;<br></code></pre></td></tr></table></figure>

<pre><code>  观察这个函数逻辑，message是我们最后要得到的明文（以下简称msg），start+1就是data开始读入msg的位置（data强换了char*类型，一次只能访问一个字符），通过读循环可知stride的值影响内层循环的结束，内层循环（stride-1）次之后，j加加stride-1次，msg也按顺序读了stride-1个字符，但是内层结束后done为0继续循环，此时外层循环又给j++，进入内层又开始j++，而外层循环进行j++的时候我们没有进行msg的读入操作，所以会跳过data里的一个字符在进行读入，以此类推直到遇到结束符号。

 这里插入一下上述代码的转换功能实现的细节：字符是以ascll码对应的值存储的，而在输出字符时会自动转换成字符输出，所以上述代码看似是读取数字，其实在printf之后会自动转换成字符串

 了解extract_message1函数逻辑后，我们想要它正常运作起来，根据“如果你正确地获取了第一个和第二个键， 将显示一条以 From： 开头的消息”的提示，再结合这个解密函数的逻辑是从一定处开始读stride-1个字符然后跳一个字符再读stride-1个字符这样循环 可以试出 start = 9，（注意数组的起点是0）stride = 3，这样从第二个F读起，每读两个跳一个，发现刚好能凑出From ：
</code></pre>
<p class='item-img' data-src='image%205.png'><img src="image%205.png" alt="image.png"></p>
<p> 于是我们想要让start &#x3D; 9，stride &#x3D; 3，而这两个值又是通过变量dummy赋值的，所以我们需要观察dummy对start，stride的转换代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">start = (<span class="hljs-type">int</span>)(**(((<span class="hljs-type">char</span>**)&amp;dummy)));  <br>stride = (<span class="hljs-type">int</span>)(**(((<span class="hljs-type">char</span>**)&amp;dummy) + <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure>

<p>start：     &amp;dummy为整数dummy的地址</p>
<p>现在强转成char*类型 从4字节转换成 指1字节值的地址 并且会是低位地址 然后解引用得到的是低位地址的值，最后强转为int 类型 因为是char值升int 所以值不会产生丢失等变化 所以start就是dummy的值的前一字节  比如dummy是 11 22 33 44 ，start &#x3D; 11.所以要想start &#x3D; 9，dummy最低位字节应该是09</p>
<p>stride：   先将强转后地址加 ‘1’再解引用，这里涉及到指针的加法运算</p>
<p>指针加法时，指针的步长是与指针所指向的数据类型的大小，强转char*型后步长变为1字节，所以stride是dummy的第二个字节，要想让stide为3，dummy的第二个字节就要为03，</p>
<p>所以整型变量dummy应该是 09 03 xx xx，才能让解码函数正常运行，我们让dummy为09 03 00 00，</p>
<p>也就是十六进制下的309，通过十六进制转十进制可以得到dummy为3*256+9&#x3D;777</p>
<p>现在我们找到了dummy的值 然而dummy被初始化为1，达不到我们的目的，蓦然回首，项目提示中有这句话</p>
<p>In breaking the first two keys, realize that the function must be somehow changing the value of the variable.  because the variables and control the extraction of the message.</p>
<p>这指示我们一定要改变dummy的值then how？<br>因为我们不能直接改变代码 我们除了分析唯一能做的事就是传参，所以我们需要通过传参来改变dummy的值，我们传的值就是key1，key2，于是乎看processkey_12函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">process_keys12</span><span class="hljs-params">(<span class="hljs-type">int</span>* key1, <span class="hljs-type">int</span>* key2)</span> &#123;  <br>**((<span class="hljs-type">int</span>**)(key1 + *key1)) = *key2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到这个函数是对传入的指针key1 key2进行操作，我们来深入分析下这个函数，</p>
<p>key1本身是指针 <em>key1解引用后也就是值，这涉及到我们刚才说的指针加法运算，key1是指向int类型的指针，所以key1 + <em>key1实际上是让指针指向的地址向后走（4 乘以 （<em>key1））个字节，然后整体再强转int</em>类型，最后再解引用，得到的是相应计算后指向的地址的4个字节的值，而赋值式子右侧的</em>key2被赋给左侧这个式子，而key1，key2本身的值是由我们传入的，所以我们可以传入key2的值使得左侧式子被赋成我们想要的值，而key1的值同样为我们所传入，左侧传入key1后可以在key1的地址上做移动使得左侧指向指定的地址的值然后被</em>key2赋值，总而言之，我们可以通过改变key1，key2的值来用这个式子改变任意已知地址变量的值为指定值</p>
<p>于是我们想用这个式子来改变dummy的值，我们打断点调试key12相关的代码然后在监视中取dummy地址和key1地址</p>
<p class='item-img' data-src='image%206.png'><img src="image%206.png" alt="image.png"></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>名称</strong></th>
<th><strong>值</strong></th>
<th><strong>类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>&amp;dummy</td>
<td>0x000000000014fc14 {1}</td>
<td>int *</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th><strong>名称</strong></th>
<th><strong>值</strong></th>
<th><strong>类型</strong></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>key1</td>
<td>0x000000000014fc74 {-24}</td>
<td>int *</td>
</tr>
</tbody></table>
<p>我们发现key1的地址比dummy高96，我们想要</p>
<p>key1 + *key1准确定位到dummy的地址，所以（<em>key1） * 4 &#x3D;-96 ，</em> key1 &#x3D; -24</p>
<p>我们想要dummy赋值为777，所以右侧*key2 &#x3D; 777。（必须在64位下）</p>
<p>我们打开vs的项目属性 在调试中传入参数 -24 ，777， 1，1（后面key34未知所以随便填）</p>
<p>运行得到以下结果</p>
<p class='item-img' data-src='image%207.png'><img src="image%207.png" alt="image.png"></p>
<p>说明key1，key2正确</p>
<h1 id="2-What-about-key3-key4"><a href="#2-What-about-key3-key4" class="headerlink" title="2.What about key3&amp;key4?"></a>2.What about key3&amp;key4?</h1><p>key1和key2相当于一个引导，因为key1，key2相关的代码和key3，key4很对仗，可以想到key3，key4就是他们的升级版</p>
<h2 id="分析得到的新tip"><a href="#分析得到的新tip" class="headerlink" title="分析得到的新tip"></a>分析得到的新tip</h2><p>我们来看破解前两个密钥后的得到的提示信息</p>
<p class='item-img' data-src='image%207.png'><img src="image%207.png" alt="image.png"></p>
<p>提示让我们找到能强制调用extract_message2函数而避免调用extract_message1的key3，key4的值</p>
<p>以下为相关部分代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (key3 != <span class="hljs-number">0</span> &amp;&amp; key4 != <span class="hljs-number">0</span>) &#123;<br>	process_keys34(&amp;key3, &amp;key4);     <span class="hljs-comment">///////////////////</span><br>&#125;<br><br>msg1 = extract_message1(start, stride);<span class="hljs-comment">/**/</span><br><br><span class="hljs-keyword">if</span> (*msg1 == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>	process_keys34(&amp;key3, &amp;key4);<span class="hljs-comment">//////////////////////</span><br>	msg2 = extract_message2(start, stride);<span class="hljs-comment">/**/</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\\n&quot;</span>, msg2);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\\n&quot;</span>, msg1);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到我用&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;标注了两个process_keys34(&amp;key3, &amp;key4)函数用&#x2F;**&#x2F;标注了extract_message1和extract_message2，根据提示我们想要跳过执行</p>
<p>msg1 &#x3D; extract_message1(start, stride);&#x2F;**&#x2F;这一句</p>
<p>然后进入if执行msg2 &#x3D; extract_message2(start, stride);&#x2F;**&#x2F;这一句就能得到正确答案</p>
<p>extract_message2(start, stride)的start和stride保持不变</p>
<p>实际上通过分析extract_message2(start, stride)的代码 我们发现它和extract_message1相似</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">extract_message2</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> stride)</span> &#123;<br><span class="hljs-type">int</span> i, j;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = start;<br>**(((<span class="hljs-type">char</span>**)data) + j) != <span class="hljs-string">&#x27;\0&#x27;</span>;<br>i++, j += stride)<br>&#123;<br>message[i] = *(((<span class="hljs-type">char</span>*)data) + j);<br>&#125;<br>message[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-keyword">return</span> message;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>它的读入方式是从data的 start位开始单层循环 每次读入一个字符然后跳stride-1个字符，如果key1，key2不变，start &#x3D; 9，stride &#x3D; 3，在这里就是从第9个字符开始读一个跳过两个，我们会发现这样读入仍然会得到有意义的字符串From ：CTE…………..</p>
<p class='item-img' data-src='image%208.png'><img src="image%208.png" alt="image.png"></p>
<p>这启示我们不用改start，stride的值和extract_message2之后怎么操作字符串，可以专一进行强制调用extract_message2函数而避免调用extract_message1的建议</p>
<h2 id="如何做到避免调用和强制调用函数"><a href="#如何做到避免调用和强制调用函数" class="headerlink" title="如何做到避免调用和强制调用函数"></a>如何做到避免调用和强制调用函数</h2><p>类比  **((int*)*(key1 + *key1)) &#x3D; *key2这个可以修改任意地址里的值的万能式子</p>
<p><strong>(((int</strong>)&amp;key3) + *key3) +&#x3D; *key4 这个式子可以让我们使得任意地址里的值加上  *key4</p>
<p>我们正是需要用到这个式子来做到强制调用函数</p>
<p>这里有两种强行步入函数的方法</p>
<h3 id="方法1-修改data对应的值满足if条件来步入条件分句"><a href="#方法1-修改data对应的值满足if条件来步入条件分句" class="headerlink" title="方法1.修改data对应的值满足if条件来步入条件分句"></a>方法1.修改data对应的值满足if条件来步入条件分句</h3><p>注意到，影响调用extract_message1还是2的if条件如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">process_keys34(&amp;key3, &amp;key4);  <br>&#125;<br>msg1 = extract_message1(start, stride);<br><br><span class="hljs-keyword">if</span> (*msg1 == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;   <span class="hljs-comment">//这里就是分支点</span><br>process_keys34(&amp;key3, &amp;key4);<br>msg2 = extract_message2(start, stride);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, msg2);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, msg1);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果<em>msg1 &#x3D;&#x3D; ‘\0’就会步入我们想要的extract_message2函数得到结果，如果我们不做任何修改，会直接执行else语句打印msg1，我们想要打印msg2，就需要满足if条件让</em>msg1&#x3D;‘\0’，而我们正好拥有改变指定地址值的power😋</p>
<p>if I want *msg1 &#x3D;&#x3D; ‘\0’,then I have to take it.（乱入）</p>
<p>想修改msg1的结果 我们需要倒回去看的读入条件extract_message1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span>* <span class="hljs-title function_">extract_message1</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> stride)</span> &#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">int</span> done = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, j = start + <span class="hljs-number">1</span>; !done; j++) &#123;<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; stride; k++, j++, i++) &#123;<br>            <span class="hljs-keyword">if</span> (*(((<span class="hljs-type">char</span>*)data) + j) == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>                done = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            message[i] = *(((<span class="hljs-type">char</span>*)data) + j);<br>        &#125;<br>    &#125;<br>    message[i] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> message;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> if (<em>(((char</em>)data) + j) &#x3D;&#x3D; ‘\0’)是中值循环的主要条件，而j第一次为start+1&#x3D;10，也就是data数组的第十个字节，如果我们把它赋值成’\0’，这个函数就会什么都不读入，message就会默认为空，</p>
<p>*msg1 &#x3D;&#x3D; ‘\0’就会成立</p>
<p>所以接下来就是运用key3，key4来修改指定值的时机了</p>
<p><strong>(((int</strong>)&amp;key3) + *key3) +&#x3D; *key4&#x2F;&#x2F;注意是 +&#x3D;</p>
<p>我们取data地址，将其第十个字符改变为 \0  （ascll里的00）&#x2F;&#x2F;注意是数组的10（从0开始）</p>
<p>直接在内存窗口里输入&amp;data回车</p>
<p class='item-img' data-src='image%209.png'><img src="image%209.png" alt="image.png"></p>
<p>我们想改第10个字节 46 为 00 ，我们的修改是int类型的，一次修改4个字节，所以找到data[2]的内存位置0x0000000140006088 将63 46 46 72（0x72464663） 改为63 46 00 72 （0x72004663）也就是让*key4 &#x3D; 两数相减为-4,587,520</p>
<p>接下来算key3 （（int*）&amp;key3 + *key3）应该表示data[2]的地址0x0000000140006088 </p>
<p>&amp;key3的值在内存中查看得到为0x000000000014fbf0  注意是&amp;key3 不是key3</p>
<p>我们让0x000000000014fbf0 +（*key3 ） *4 &#x3D; 0x0000000140006088 （指针运算法则）</p>
<p>经过计算得到*key3 &#x3D; 5367358616&#x2F;4&#x3D;1341839654  </p>
<p>&#x2F;&#x2F;这种方法的*key4应该一致，key3地址偏移量会根据机器不同而不同</p>
<p>我们将四个值传入运行 </p>
<p class='item-img' data-src='image%2010.png'><img src="image%2010.png" alt="image.png"></p>
<p class='item-img' data-src='image%2011.png'><img src="image%2011.png" alt="image.png"></p>
<p>最后结果如上 这代表我们传入的四个值都正确</p>
<h3 id="方法2-利用栈帧分析改变函数的返回地址"><a href="#方法2-利用栈帧分析改变函数的返回地址" class="headerlink" title="方法2 利用栈帧分析改变函数的返回地址"></a>方法2 利用栈帧分析改变函数的返回地址</h3><p>再次强调 64位和x86结果不同 不过两种情况下的分析方法相同</p>
<p>我们回到找key3，key4要解决的问题：强制调用extract_message2函数而避免调用extract_message1</p>
<p>上一种方法我们用的代码里给的if语句修改值满足条件步入extract_message2，这里我们使用修改函数的返回地址的方法来达到目的 ，这需要一点栈帧结构的知识 </p>
<p>【C程序在内存中的栈】 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1By4y1x7Yh/?share_source=copy_web&vd_source=d8b8c07d289d045ecef7ba91bfa51e69">https://www.bilibili.com/video/BV1By4y1x7Yh/?share_source&#x3D;copy_web&amp;vd_source&#x3D;d8b8c07d289d045ecef7ba91bfa51e69</a></p>
<p>64位下栈顶为RSP 栈底为RBP</p>
<p>x86下栈顶为ESP 栈底为EBP </p>
<p>在一个函数的反汇编的代码末尾处 栈顶RSP会指向函数的返回地址 我们只需要记住这一点就能分析</p>
<p>这次需要我们打开寄存器和反汇编</p>
<p>我们在process_keys34处打断点 调试到这一步的时候会步入process_keys34的定义</p>
<p>调试 </p>
<p class='item-img' data-src='image%2012.png'><img src="image%2012.png" alt="image.png"></p>
<p class='item-img' data-src='image%2013.png'><img src="image%2013.png" alt="image.png"></p>
<p>在反汇编中可以看到两个process_keys34的反汇编代码 他们对应的最后一条代码左侧的地址就是返回地址所在地址，我们所做的就是将第一个代码的返回地址改成到第二个代码的返回地址，这样就能实现步入extract_message2函数</p>
<p>可以看到第一个process_keys34返回地址是0000000140001533 </p>
<pre><code>           第二个process_keys34返回地址是0000000140001567
</code></pre>
<p>两者相差52（注意是16进制啊喂）也就是我们想要将存放返回地址的指针里的值加52</p>
<p>上面已经提到 这个存放返回地址的指针就是栈顶RSP 所以我们查看寄存器RSP的值</p>
<p>点击反汇编窗口使得调试过程在反汇编中进行 一步步调试知道转到process_keys34的定义 在调试箭头指向定义最后的ret处时查看寄存器RSP</p>
<p class='item-img' data-src='image%2014.png'><img src="image%2014.png" alt="image.png"></p>
<p>此时查看寄存器RSP&#x3D;000000000014FBE8 这个地址存放的就是第一个函数process的返回地址</p>
<p class='item-img' data-src='image%2015.png'><img src="image%2015.png" alt="image.png"></p>
<p>通过查看内存也可以验证这一点</p>
<p class='item-img' data-src='image%2016.png'><img src="image%2016.png" alt="image.png"></p>
<p>刚好就是0000000140001533 和刚才第一个process函数返回地址相同</p>
<p>所以接下来我们就利用power改变RSP的值 让他加上52</p>
<p>我们又回到了key3 key4的这个式子</p>
<p class='item-img' data-src='image%2017.png'><img src="image%2017.png" alt="image.png"></p>
<p>让*key4 &#x3D; 52 （其实也可以是53，因为procee_key34最后一条汇编指令本身就是空指令nop 不执行也没关系）</p>
<p><em>让(<em>key3 + ((int</em></em>)&amp;key3))) 为RSP地址000000000014FBE8</p>
<p>查看&amp;key3为000000000014fbf0 通过指针运算 4*（*key3）+&amp;key3 &#x3D; 000000000014FBE8</p>
<p>求得*key3 &#x3D;-2（注意负号）</p>
<p>所以此时*key3 &#x3D; -2 *key4 &#x3D; 52或53</p>
<p class='item-img' data-src='image%2018.png'><img src="image%2018.png" alt="image.png"></p>
<p>运行发现也能得出相应正确结果</p>
<p class='item-img' data-src='image%2019.png'><img src="image%2019.png" alt="image.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>1.x86架构下用修改函数返回地址方法做出的结果如下</p>
<p class='item-img' data-src='image%2020.png'><img src="image%2020.png" alt="image.png"></p>
<p>其实777（ *key2或dummy的值）有很多种情况 因为start 和stride只取了它的第一字节和第二字节地址 剩下的两个字节地址均可以任意填充</p>
<p>2.心得体会 </p>
<p>提示建议的作用很大 比如改变dummy变量的值和步入extract_message2函数这两个提示</p>
<p>还有这两个我们的作用式子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">process_keys12</span><span class="hljs-params">(<span class="hljs-type">int</span>* key1, <span class="hljs-type">int</span>* key2)</span> &#123;<br>**((<span class="hljs-type">int</span>**)(key1 + *key1)) = key2;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">process_keys34</span><span class="hljs-params">(<span class="hljs-type">int</span> key3, <span class="hljs-type">int</span>* key4)</span> &#123;<br><br>**(((<span class="hljs-type">int</span>**)&amp;key3) + *key3) += *key4;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>有了这两个函数我们可以改变任意变量的值  还记得我理解这个式子的作用时的喜悦，感觉拥有了帕瓦，简直是超模😋</p>
<p>3.栈帧结构的入门太简单了，根本无法独立做题，希望以后老师给的的入门教程能多一点</p>
<p>4.不同的环境下的结果不同，不同的方法结果也不同，题目的解答多样化，很好地体现了我们面向实际的理工科性质，现实情况只会更加复杂</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>这题的思路主要总结了前几位学长的思路方法，博客链接或视频链接如下</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/uuzeray/article/details/134984904?ops_request_misc=%257B%2522request%255Fid%2522%253A%25224d47472e625578c179d4f2e6c489b0ff%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=4d47472e625578c179d4f2e6c489b0ff&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-134984904-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=%E5%9B%9B%E5%B7%9D%E5%A4%A7%E5%AD%A6%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AEfindkeys&spm=1018.2226.3001.4187">【C语言】SCU安全项目1-FindKeys_findkeysc语言-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CD4y1c7Qn/?spm_id_from=333.337.search-card.all.click&vd_source=46a9e0cd66aa17a4103b311e6485b293">四川大学程序设计基础(C语言)与安全 安全项目讲解（lab1 Decode项目）_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ay421h7MP/?spm_id_from=333.337.search-card.all.click&vd_source=46a9e0cd66aa17a4103b311e6485b293">【四川大学网安】Lab1-Decode（网安大一上C语言作业）_哔哩哔哩_bilibili</a></p>
<div id="paginator"></div></div><div id="post-footer"></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="To Top" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="To Catalog">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="Change Theme"></a><a onclick="BgmControl()"><svg id="bgm-control" viewBox="0 0 30 34" fill="currentColor" style="width: 24px; transition: transform .3s;margin-top: 4px"><path d="M25.998 23.422V11.29h3.999v12.132h-3.999zM19.497 6.234h4.001v22.243h-4.001V6.234zM12.998.867h4v32.978h-4V.867zm-6.5 5.367h4.001v22.243H6.498V6.234zm-6.5 5.056h4v12.132h-4V11.29z"></path></svg><audio id="bgm" src="/audio/bgm.mp3" loop crossorigin="anonymous"> </audio></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo" style="margin:0;border-radius:0;"></a><h1 id="Dr"><a href="/">HxChimenG</a></h1><div id="description"><p>这个人很懒</p></div></div><div id="aside-block"><div id="toc-div"><h1>Catalog</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AEfindkeys%EF%BC%88decode%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">安全项目findkeys（decode）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%A6%81%E6%B1%82"><span class="toc-number">1.1.</span> <span class="toc-text">项目要求</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E6%89%BE%E5%88%B0key12"><span class="toc-number">2.</span> <span class="toc-text">1. 找到key12</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%98From%EF%BC%9A%E2%80%99%E4%BB%8E%E5%93%AA%E6%9D%A5%EF%BC%9F"><span class="toc-number">2.0.1.</span> <span class="toc-text">‘From：’从哪来？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AF%BB%E5%87%BA%E6%98%8E%E6%96%87%E5%B9%B6%E6%89%BE%E5%88%B0key%E5%80%BC%F0%9F%A4%94"><span class="toc-number">2.0.2.</span> <span class="toc-text">如何读出明文并找到key值🤔</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-What-about-key3-key4"><span class="toc-number">3.</span> <span class="toc-text">2.What about key3&amp;key4?</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E5%BE%97%E5%88%B0%E7%9A%84%E6%96%B0tip"><span class="toc-number">3.1.</span> <span class="toc-text">分析得到的新tip</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E9%81%BF%E5%85%8D%E8%B0%83%E7%94%A8%E5%92%8C%E5%BC%BA%E5%88%B6%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">如何做到避免调用和强制调用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951-%E4%BF%AE%E6%94%B9data%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%E6%BB%A1%E8%B6%B3if%E6%9D%A1%E4%BB%B6%E6%9D%A5%E6%AD%A5%E5%85%A5%E6%9D%A1%E4%BB%B6%E5%88%86%E5%8F%A5"><span class="toc-number">3.2.1.</span> <span class="toc-text">方法1.修改data对应的值满足if条件来步入条件分句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952-%E5%88%A9%E7%94%A8%E6%A0%88%E5%B8%A7%E5%88%86%E6%9E%90%E6%94%B9%E5%8F%98%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%9C%B0%E5%9D%80"><span class="toc-number">3.2.2.</span> <span class="toc-text">方法2 利用栈帧分析改变函数的返回地址</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">4.0.1.</span> <span class="toc-text">补充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">4.0.2.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>Published with <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> Theme <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> by <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><!-- hexo injector body_end start --><script data-pjax src="https://registry.npmmirror.com/oh-my-live2d/latest/files"></script><script>const oml2d = OML2D.loadOml2d({dockedPosition:"right",libraryUrls:{"complete":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/complete.js","cubism2":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism2.js","cubism5":"https://registry.npmmirror.com/oh-my-live2d/latest/files/lib/cubism5.js"},mobileDisplay:true,models:[{"path":"http://hxchimeng.xyz/live2d-models/阿米娅(1).model3.json","resources":{"moc":"http://hxchimeng.xyz/live2d-models/阿米娅(1).moc3","textures":["http://hxchimeng.xyz/live2d-models/阿米娅(1).8192/texture_00.png"],"physics":"http://hxchimeng.xyz/live2d-models/阿米娅(1).physics3.json","displayInfo":"http://hxchimeng.xyz/live2d-models/阿米娅(1).cdi3.json"},"scale":0.06,"position":[50,50],"stageStyle":{"width":600,"height":330}}],parentElement:document.body,primaryColor:"var(--btn-bg)",sayHello:true,tips:{style: {"width":180,"height":100,"left":"calc(50% - 20px)","top":"-100px"},mobileStyle: {"width":180,"height":80,"left":"calc(50% - 30px)","top":"-100px"}},stageStyle:{"background-color":"transparent"},idleTips:{"interval":15000,"message":"function(){\n  return axios.get('https://v1.hitokoto.cn?c=i')\n    .then(function (response) {\n      return response.data.hitokoto ;\n    })\n    .catch(function (error) {\n      console.error(error);\n    });\n}\n"}});</script><!-- hexo injector body_end end --></body></html>