[{"title":"findkeys(decode)安全实验","url":"/2025/03/21/%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AEfindkeys%EF%BC%88decode%EF%BC%89%E5%A4%A7%E4%B8%80%E4%B8%8A%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/","content":"安全项目findkeys（decode）项目要求主要目的：解码消息并找到密钥key1，key2，key3，key4的值，以下操作均在64位架构下进行（x86架构下会有不同结果也会附到后面）\n1. 找到key12‘From：’从哪来？提示中告诉我们先找key1 key2：attack the keys in two independent parts. Try to break the first two keys first. \n并且告诉我们如果key1key2正确 得到的对应结果前面会出现From:    （If you get the first and second keys right, a message that starts with From: will appear. ）\n根据建议，先找key12的值，先看process_key12和extract_message12，前者是对我们即将传入的密钥值进行的操作，后者extract_message12通过读代码不难发现其实就是解密函数，而data就是密文\ndata值如下\nint data[] = &#123;       //数据 密文0x63636363, 0x63636363, 0x72464663, 0x6F6D6F72,0x466D203A, 0x65693A72, 0x43646E20, 0x6F54540A,0x5920453A, 0x54756F0A, 0x6F6F470A, 0x21643A6F,0x594E2020, 0x206F776F, 0x79727574, 0x4563200A,0x6F786F68, 0x6E696373, 0x6C206765, 0x796C656B,0x2C336573, 0x7420346E, 0x20216F74, 0x726F5966,0x7565636F, 0x20206120, 0x6C616763, 0x74206C6F,0x20206F74, 0x74786565, 0x65617276, 0x32727463,0x6E617920, 0x680A6474, 0x6F697661, 0x20646E69,0x21687467, 0x63002065, 0x6C6C7861, 0x78742078,0x6578206F, 0x72747878, 0x78636178, 0x00783174&#125;;\n\n    可以看出它是多个8位16进制数组合的数组，8位十六进制刚好是32位，也就是4字节（int类型）。\n    想要得出具有有意义的内容，不难想到16进制转字符串，一个字符（char类型）1字节对应两个16进制数字，\n    于是我们将去掉0x前缀和逗号的内容粘贴到转换网站里\n\n6363636363636363724646636F6D6F72466D203A65693A7243646E206F54540A5920453A54756F0A6F6F470A21643A6F594E2020206F776F797275744563200A6F786F686E6963736C206765796C656B2C3365737420346E20216F74726F59667565636F202061206C61676374206C6F20206F747478656565617276327274636E617920680A64746F69766120646E6921687467630020656C6C7861787420786578206F727478787863617800783174\n\n 然而通过后面的解码函数extract_message12的解码逻辑（指定方式的顺序读入message来生成明文）看，以上转换是无法得出正确的转换结果的\n ，因为其中含有无法正常阅读的符号\n\n   🤔那么问题出现在哪里呢，我们以0x72464663举例 ，7是最高位，3是最低位，观察内存可以发现这串数在内存中的存储方式是  63 46 46 72（内存的单位是字节，两个16进制一组），这叫做小端顺序，即低位地址在地址的低位（地址是从低到高看，前低后高）\n\n   所以data的读取方式应该是每组数以两个数为单位从后向前读，也就是0x72 46 46 63，                     \n   应该以63 46 46 72的顺序转换，所以自己写一个对应的解码程序,以下是正确结果\n\n\n转换代码如下（其实是gpt写的😋）\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;void hex_to_string(int *data, size_t len, char *output) &#123;    size_t j = 0;    for (size_t i = 0; i &lt; len; i++) &#123;        // 按小端顺序处理32位数据中的每个字节        unsigned char byte1 = (data[i] &amp; 0xFF);        unsigned char byte2 = ((data[i] &gt;&gt; 8) &amp; 0xFF);        unsigned char byte3 = ((data[i] &gt;&gt; 16) &amp; 0xFF);        unsigned char byte4 = ((data[i] &gt;&gt; 24) &amp; 0xFF);                // 存储每个字节到output字符串        output[j++] = byte1;        output[j++] = byte2;        output[j++] = byte3;        output[j++] = byte4;    &#125;    output[j] = &#x27;\\0&#x27;;  // 添加字符串结束符&#125;int main() &#123;    int data[] = &#123;  // 数据 密文        0x63636363, 0x63636363, 0x72464663, 0x6F6D6F72,        0x466D203A, 0x65693A72, 0x43646E20, 0x6F54540A,        0x5920453A, 0x54756F0A, 0x6F6F470A, 0x21643A6F,        0x594E2020, 0x206F776F, 0x79727574, 0x4563200A,        0x6F786F68, 0x6E696373, 0x6C206765, 0x796C656B,        0x2C336573, 0x7420346E, 0x20216F74, 0x726F5966,        0x7565636F, 0x20206120, 0x6C616763, 0x74206C6F,        0x20206F74, 0x74786565, 0x65617276, 0x32727463,        0x6E617920, 0x680A6474, 0x6F697661, 0x20646E69,        0x21687467, 0x63002065, 0x6C6C7861, 0x78742078,        0x6578206F, 0x72747878, 0x78636178, 0x00783174    &#125;;        size_t len = sizeof(data) / sizeof(data[0]);  // 密文数据的元素数量    char output[len * 4 + 1];  // 存储转换后的字符串        hex_to_string(data, len, output);    printf(&quot;转换后的字符串:\\n%s\\n&quot;, output);        return 0;&#125;\n\n 除了自己敲代码转换之外 ，我们可以以一种简单方式直接找到转换后的结果\n\n我们可以直接打断点在程序内调试 在内存中查看&amp;data的值，内存中本来就是小端顺序 所以内存右侧就是正确的转换结果\n\n右侧就是vs自动帮我们转换的对应结果，截取放大如下\n\n\n如何读出明文并找到key值🤔通过提示“如果你正确地获取了第一个和第二个键， 将显示一条以 From： 开头的消息”\n而extract_message1函数经过观察就是对data进行转换的解密函数，它的运行需要两个参数\nstart（起点）和stride（步长），而这两个参数又是通过dummy变量赋值的\n解码函数代码如下\n  char* extract_message1(int start, int stride) &#123;\tint i, j, k;\tint done = 0;\tfor (i = 0, j = start + 1; !done; j++) &#123;         \t\tfor (k = 1; k &lt; stride; k++, j++, i++) &#123;\t\t\tif (*(((char*)data) + j) == &#x27;\\0&#x27;) &#123;  \t\t\t\tdone = 1;\t\t\t\tbreak;\t\t\t&#125;\t\t\tmessage[i] = *(((char*)data) + j);\t\t&#125;\t&#125;\tmessage[i] = &#x27;\\0&#x27;;\treturn message;&#125;\n\n  观察这个函数逻辑，message是我们最后要得到的明文（以下简称msg），start+1就是data开始读入msg的位置（data强换了char*类型，一次只能访问一个字符），通过读循环可知stride的值影响内层循环的结束，内层循环（stride-1）次之后，j加加stride-1次，msg也按顺序读了stride-1个字符，但是内层结束后done为0继续循环，此时外层循环又给j++，进入内层又开始j++，而外层循环进行j++的时候我们没有进行msg的读入操作，所以会跳过data里的一个字符在进行读入，以此类推直到遇到结束符号。\n\n 这里插入一下上述代码的转换功能实现的细节：字符是以ascll码对应的值存储的，而在输出字符时会自动转换成字符输出，所以上述代码看似是读取数字，其实在printf之后会自动转换成字符串\n\n 了解extract_message1函数逻辑后，我们想要它正常运作起来，根据“如果你正确地获取了第一个和第二个键， 将显示一条以 From： 开头的消息”的提示，再结合这个解密函数的逻辑是从一定处开始读stride-1个字符然后跳一个字符再读stride-1个字符这样循环 可以试出 start = 9，（注意数组的起点是0）stride = 3，这样从第二个F读起，每读两个跳一个，发现刚好能凑出From ：\n\n\n 于是我们想要让start &#x3D; 9，stride &#x3D; 3，而这两个值又是通过变量dummy赋值的，所以我们需要观察dummy对start，stride的转换代码\nstart = (int)(**(((char**)&amp;dummy)));  stride = (int)(**(((char**)&amp;dummy) + 1));\n\nstart：     &amp;dummy为整数dummy的地址\n现在强转成char*类型 从4字节转换成 指1字节值的地址 并且会是低位地址 然后解引用得到的是低位地址的值，最后强转为int 类型 因为是char值升int 所以值不会产生丢失等变化 所以start就是dummy的值的前一字节  比如dummy是 11 22 33 44 ，start &#x3D; 11.所以要想start &#x3D; 9，dummy最低位字节应该是09\nstride：   先将强转后地址加 ‘1’再解引用，这里涉及到指针的加法运算\n指针加法时，指针的步长是与指针所指向的数据类型的大小，强转char*型后步长变为1字节，所以stride是dummy的第二个字节，要想让stide为3，dummy的第二个字节就要为03，\n所以整型变量dummy应该是 09 03 xx xx，才能让解码函数正常运行，我们让dummy为09 03 00 00，\n也就是十六进制下的309，通过十六进制转十进制可以得到dummy为3*256+9&#x3D;777\n现在我们找到了dummy的值 然而dummy被初始化为1，达不到我们的目的，蓦然回首，项目提示中有这句话\nIn breaking the first two keys, realize that the function must be somehow changing the value of the variable.  because the variables and control the extraction of the message.\n这指示我们一定要改变dummy的值then how？因为我们不能直接改变代码 我们除了分析唯一能做的事就是传参，所以我们需要通过传参来改变dummy的值，我们传的值就是key1，key2，于是乎看processkey_12函数\nvoid process_keys12(int* key1, int* key2) &#123;  **((int**)(key1 + *key1)) = *key2;&#125;\n\n可以看到这个函数是对传入的指针key1 key2进行操作，我们来深入分析下这个函数，\nkey1本身是指针 key1解引用后也就是值，这涉及到我们刚才说的指针加法运算，key1是指向int类型的指针，所以key1 + key1实际上是让指针指向的地址向后走（4 乘以 （key1））个字节，然后整体再强转int类型，最后再解引用，得到的是相应计算后指向的地址的4个字节的值，而赋值式子右侧的key2被赋给左侧这个式子，而key1，key2本身的值是由我们传入的，所以我们可以传入key2的值使得左侧式子被赋成我们想要的值，而key1的值同样为我们所传入，左侧传入key1后可以在key1的地址上做移动使得左侧指向指定的地址的值然后被key2赋值，总而言之，我们可以通过改变key1，key2的值来用这个式子改变任意已知地址变量的值为指定值\n于是我们想用这个式子来改变dummy的值，我们打断点调试key12相关的代码然后在监视中取dummy地址和key1地址\n\n\n\n\n\n名称\n值\n类型\n\n\n\n\n&amp;dummy\n0x000000000014fc14 {1}\nint *\n\n\n\n\n\n\n名称\n值\n类型\n\n\n\n\nkey1\n0x000000000014fc74 {-24}\nint *\n\n\n我们发现key1的地址比dummy高96，我们想要\nkey1 + *key1准确定位到dummy的地址，所以（key1） * 4 &#x3D;-96 ， key1 &#x3D; -24\n我们想要dummy赋值为777，所以右侧*key2 &#x3D; 777。（必须在64位下）\n我们打开vs的项目属性 在调试中传入参数 -24 ，777， 1，1（后面key34未知所以随便填）\n运行得到以下结果\n\n说明key1，key2正确\n2.What about key3&amp;key4?key1和key2相当于一个引导，因为key1，key2相关的代码和key3，key4很对仗，可以想到key3，key4就是他们的升级版\n分析得到的新tip我们来看破解前两个密钥后的得到的提示信息\n\n提示让我们找到能强制调用extract_message2函数而避免调用extract_message1的key3，key4的值\n以下为相关部分代码\nif (key3 != 0 &amp;&amp; key4 != 0) &#123;\tprocess_keys34(&amp;key3, &amp;key4);     ///////////////////&#125;msg1 = extract_message1(start, stride);/**/if (*msg1 == &#x27;\\0&#x27;) &#123;\tprocess_keys34(&amp;key3, &amp;key4);//////////////////////\tmsg2 = extract_message2(start, stride);/**/\tprintf(&quot;%s\\\\n&quot;, msg2);&#125;else &#123;\tprintf(&quot;%s\\\\n&quot;, msg1);&#125;return 0;&#125;\n\n可以看到我用&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;标注了两个process_keys34(&amp;key3, &amp;key4)函数用&#x2F;**&#x2F;标注了extract_message1和extract_message2，根据提示我们想要跳过执行\nmsg1 &#x3D; extract_message1(start, stride);&#x2F;**&#x2F;这一句\n然后进入if执行msg2 &#x3D; extract_message2(start, stride);&#x2F;**&#x2F;这一句就能得到正确答案\nextract_message2(start, stride)的start和stride保持不变\n实际上通过分析extract_message2(start, stride)的代码 我们发现它和extract_message1相似\nchar* extract_message2(int start, int stride) &#123;int i, j;for (i = 0, j = start;**(((char**)data) + j) != &#x27;\\0&#x27;;i++, j += stride)&#123;message[i] = *(((char*)data) + j);&#125;message[i] = &#x27;\\0&#x27;;return message;&#125;\n\n它的读入方式是从data的 start位开始单层循环 每次读入一个字符然后跳stride-1个字符，如果key1，key2不变，start &#x3D; 9，stride &#x3D; 3，在这里就是从第9个字符开始读一个跳过两个，我们会发现这样读入仍然会得到有意义的字符串From ：CTE…………..\n\n这启示我们不用改start，stride的值和extract_message2之后怎么操作字符串，可以专一进行强制调用extract_message2函数而避免调用extract_message1的建议\n如何做到避免调用和强制调用函数类比  **((int*)*(key1 + *key1)) &#x3D; *key2这个可以修改任意地址里的值的万能式子\n(((int)&amp;key3) + *key3) +&#x3D; *key4 这个式子可以让我们使得任意地址里的值加上  *key4\n我们正是需要用到这个式子来做到强制调用函数\n这里有两种强行步入函数的方法\n方法1.修改data对应的值满足if条件来步入条件分句注意到，影响调用extract_message1还是2的if条件如下\nprocess_keys34(&amp;key3, &amp;key4);  &#125;msg1 = extract_message1(start, stride);if (*msg1 == &#x27;\\0&#x27;) &#123;   //这里就是分支点process_keys34(&amp;key3, &amp;key4);msg2 = extract_message2(start, stride);printf(&quot;%s\\n&quot;, msg2);&#125;else &#123;printf(&quot;%s\\n&quot;, msg1);&#125;\n\n如果msg1 &#x3D;&#x3D; ‘\\0’就会步入我们想要的extract_message2函数得到结果，如果我们不做任何修改，会直接执行else语句打印msg1，我们想要打印msg2，就需要满足if条件让msg1&#x3D;‘\\0’，而我们正好拥有改变指定地址值的power😋\nif I want *msg1 &#x3D;&#x3D; ‘\\0’,then I have to take it.（乱入）\n想修改msg1的结果 我们需要倒回去看的读入条件extract_message1\nchar* extract_message1(int start, int stride) &#123;    int i, j, k;    int done = 0;    for (i = 0, j = start + 1; !done; j++) &#123;        for (k = 1; k &lt; stride; k++, j++, i++) &#123;            if (*(((char*)data) + j) == &#x27;\\0&#x27;) &#123;                done = 1;                break;            &#125;            message[i] = *(((char*)data) + j);        &#125;    &#125;    message[i] = &#x27;\\0&#x27;;    return message;&#125;\n\n if ((((char)data) + j) &#x3D;&#x3D; ‘\\0’)是中值循环的主要条件，而j第一次为start+1&#x3D;10，也就是data数组的第十个字节，如果我们把它赋值成’\\0’，这个函数就会什么都不读入，message就会默认为空，\n*msg1 &#x3D;&#x3D; ‘\\0’就会成立\n所以接下来就是运用key3，key4来修改指定值的时机了\n(((int)&amp;key3) + *key3) +&#x3D; *key4&#x2F;&#x2F;注意是 +&#x3D;\n我们取data地址，将其第十个字符改变为 \\0  （ascll里的00）&#x2F;&#x2F;注意是数组的10（从0开始）\n直接在内存窗口里输入&amp;data回车\n\n我们想改第10个字节 46 为 00 ，我们的修改是int类型的，一次修改4个字节，所以找到data[2]的内存位置0x0000000140006088 将63 46 46 72（0x72464663） 改为63 46 00 72 （0x72004663）也就是让*key4 &#x3D; 两数相减为-4,587,520\n接下来算key3 （（int*）&amp;key3 + *key3）应该表示data[2]的地址0x0000000140006088 \n&amp;key3的值在内存中查看得到为0x000000000014fbf0  注意是&amp;key3 不是key3\n我们让0x000000000014fbf0 +（*key3 ） *4 &#x3D; 0x0000000140006088 （指针运算法则）\n经过计算得到*key3 &#x3D; 5367358616&#x2F;4&#x3D;1341839654  \n&#x2F;&#x2F;这种方法的*key4应该一致，key3地址偏移量会根据机器不同而不同\n我们将四个值传入运行 \n\n\n最后结果如上 这代表我们传入的四个值都正确\n方法2 利用栈帧分析改变函数的返回地址再次强调 64位和x86结果不同 不过两种情况下的分析方法相同\n我们回到找key3，key4要解决的问题：强制调用extract_message2函数而避免调用extract_message1\n上一种方法我们用的代码里给的if语句修改值满足条件步入extract_message2，这里我们使用修改函数的返回地址的方法来达到目的 ，这需要一点栈帧结构的知识 \n【C程序在内存中的栈】 https://www.bilibili.com/video/BV1By4y1x7Yh/?share_source&#x3D;copy_web&amp;vd_source&#x3D;d8b8c07d289d045ecef7ba91bfa51e69\n64位下栈顶为RSP 栈底为RBP\nx86下栈顶为ESP 栈底为EBP \n在一个函数的反汇编的代码末尾处 栈顶RSP会指向函数的返回地址 我们只需要记住这一点就能分析\n这次需要我们打开寄存器和反汇编\n我们在process_keys34处打断点 调试到这一步的时候会步入process_keys34的定义\n调试 \n\n\n在反汇编中可以看到两个process_keys34的反汇编代码 他们对应的最后一条代码左侧的地址就是返回地址所在地址，我们所做的就是将第一个代码的返回地址改成到第二个代码的返回地址，这样就能实现步入extract_message2函数\n可以看到第一个process_keys34返回地址是0000000140001533 \n           第二个process_keys34返回地址是0000000140001567\n\n两者相差52（注意是16进制啊喂）也就是我们想要将存放返回地址的指针里的值加52\n上面已经提到 这个存放返回地址的指针就是栈顶RSP 所以我们查看寄存器RSP的值\n点击反汇编窗口使得调试过程在反汇编中进行 一步步调试知道转到process_keys34的定义 在调试箭头指向定义最后的ret处时查看寄存器RSP\n\n此时查看寄存器RSP&#x3D;000000000014FBE8 这个地址存放的就是第一个函数process的返回地址\n\n通过查看内存也可以验证这一点\n\n刚好就是0000000140001533 和刚才第一个process函数返回地址相同\n所以接下来我们就利用power改变RSP的值 让他加上52\n我们又回到了key3 key4的这个式子\n\n让*key4 &#x3D; 52 （其实也可以是53，因为procee_key34最后一条汇编指令本身就是空指令nop 不执行也没关系）\n让(key3 + ((int)&amp;key3))) 为RSP地址000000000014FBE8\n查看&amp;key3为000000000014fbf0 通过指针运算 4*（*key3）+&amp;key3 &#x3D; 000000000014FBE8\n求得*key3 &#x3D;-2（注意负号）\n所以此时*key3 &#x3D; -2 *key4 &#x3D; 52或53\n\n运行发现也能得出相应正确结果\n\n总结补充1.x86架构下用修改函数返回地址方法做出的结果如下\n\n其实777（ *key2或dummy的值）有很多种情况 因为start 和stride只取了它的第一字节和第二字节地址 剩下的两个字节地址均可以任意填充\n2.心得体会 \n提示建议的作用很大 比如改变dummy变量的值和步入extract_message2函数这两个提示\n还有这两个我们的作用式子\nvoid process_keys12(int* key1, int* key2) &#123;**((int**)(key1 + *key1)) = key2;&#125;void process_keys34(int key3, int* key4) &#123;**(((int**)&amp;key3) + *key3) += *key4;&#125;\n\n有了这两个函数我们可以改变任意变量的值  还记得我理解这个式子的作用时的喜悦，感觉拥有了帕瓦，简直是超模😋\n3.栈帧结构的入门太简单了，根本无法独立做题，希望以后老师给的的入门教程能多一点\n4.不同的环境下的结果不同，不同的方法结果也不同，题目的解答多样化，很好地体现了我们面向实际的理工科性质，现实情况只会更加复杂\n参考资料这题的思路主要总结了前几位学长的思路方法，博客链接或视频链接如下\n【C语言】SCU安全项目1-FindKeys_findkeysc语言-CSDN博客\n四川大学程序设计基础(C语言)与安全 安全项目讲解（lab1 Decode项目）_哔哩哔哩_bilibili\n【四川大学网安】Lab1-Decode（网安大一上C语言作业）_哔哩哔哩_bilibili\n","categories":["SCU安全实验"],"tags":["SCU安全实验"]},{"title":"deadbeef安全实验","url":"/2025/03/21/%E5%AE%89%E5%85%A8%E9%A1%B9%E7%9B%AEdeadbeef%E6%8A%A5%E5%91%8A%20%E5%A4%A7%E4%B8%80%E4%B8%8A%E5%AE%89%E5%85%A8%E5%AE%9E%E9%AA%8C/","content":"安全项目deadbeef报告开始项目之前vs项目属性中一定要关掉安全检查和随机基址\n\n\n以下操作在x86环境下进行\n代码审计项目源码\n/* bufbomb.c* Bomb program that is solved using a buffer overflow attack* program for CS:APP problem 3.38* used for CS 202 HW 8 part 2** compile using:* gcc -g -O2 -Os -o bufbomb bufbomb.c*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;ctype.h&gt;/* Like gets, except that characters are typed as pairs of hex digits.   Nondigit characters are ignored. Stops when encounters newline */char *getxs(char *dest) &#123;    int c;    int even = 1; /* Have read even number of digits */    int otherd = 0; /* Other hex digit of pair */    char *sp = dest;    while ((c = getchar()) != EOF &amp;&amp; c != &#x27;\\n&#x27;) &#123;        if (isxdigit(c)) &#123;            int val;            if (&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;)                val = c - &#x27;0&#x27;;            else if (&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;F&#x27;)                val = c - &#x27;A&#x27; + 10;            else                val = c - &#x27;a&#x27; + 10;            if (even) &#123;                otherd = val;                even = 0;            &#125; else &#123;                *sp++ = otherd * 16 + val;                even = 1;            &#125;        &#125;    &#125;    *sp++ = &#x27;\\0&#x27;;    return dest;&#125;int getbuf() &#123;    char buf[16];    getxs(buf);    return 1;&#125;void test() &#123;    int val;    printf(&quot;Type Hex string:&quot;);    val = getbuf();    printf(&quot;getbuf returned 0x%x\\n&quot;, val);&#125;int main() &#123;    int buf[16];    /* This little hack is an attempt to get the stack to be in a       stable position */    int offset = (((int) buf) &amp; 0xFFF);    int *space = (int *) malloc(offset);    space = 0; /* So that don&#x27;t get complaint of unused variable */    test();    return 0;&#125;\n\n代码实现了定义一个类似gets（被列为不安全函数）的getxs函数来读入16字节16进制字符存入buf[]数组中，并且getxs会读入地址dest后且无长度限制，这就有缓冲区溢出的风险，我们运行代码，随便输入一串字符，发现都会返回0x1，这是因为最后会打印0x+val的值，而val被赋值为getbuf的返回值，这个返回值为1。\n明确目的我们想要程序输出0xdeadbeef，就要让val的值为deadbeef，并且跳过getbuf（）对val的赋值操作\n直接进行打印操作（需要查看反汇编），并且我们需要利用缓冲区溢出来完成这一操作。\n具体实现我们在val &#x3D; getbuf（）赋值操作处打断点调试\n有了第一题的修改返回地址的基础 我们的目的应该很明明确， getbuf（）函数返回地址原来应该在这句赋值语句，我们要让getbuf返回地址跳过赋值，直接进行printf操作，查看反汇编\ngetbuf（）返回地址为00401186\n我们想要它跳到赋值后的printf的第一个语句 00401189\n\n我们只能通过缓冲区溢出的方法修改数据，所以我们需要思考如何利用溢出来修改返回地址和对val赋值，函数的返回地址存在寄存器栈顶ESP中，所以我们需要查看寄存器\n仍从val &#x3D; getbuf（）；处调试，查看寄存器，发现栈底EBP  &#x3D; 0019FED8 栈顶 ESP &#x3D; 0019FED4,\n接着调试发现栈顶先上升到0019FED0,栈底不变（上低地址，下高地址），再逐语句到getxs处，发现ESP变为0019FEBC,EBP变为0019FECC(此时查看内存地址可以发现其储存的值就是上次EBP的地址0019FED8)\n接着在反汇编中调试 我们逐语句，在弹出的命令窗口随便填些数字，直到箭头指向getbuf定义中的ret处\n\n此时查看ESP地址，我们知道此时该地址存放的就是getbuf的返回地址查看内存发现确实是00401186\nESP地址为0019FED0，EBP为0019FED8，如此我们便了解了栈的变换过程和函数返回地址的位置\n接下来看val和buf的相对位置以便我们将char buf[16]的值进行扩写，覆盖掉栈中返回地址和修改val的值。\n查看val的地址为 0x0019FED4 buf的地址为0019FEBC，它会存储16个字节\n我们来画栈图\n\n通过画出栈图我们清晰的认识到各个内存地址的相对位置，我们根据这个来写payload传参\n首先要写32个十六进制数字 12345678123456781234567812345678\n之后是缓冲区溢出的内容EBP是栈底 防止栈紊乱，EBP不能修改，我们仍然填入0019FED8，不过由于是小端存储，我们传参的时候要传入 D8 FE 19 00 \n再往后是ESP 也就是我们想要修改的返回地址处，此处改为 89 11 40 00\n然后是val的值 我们填入deadbeef 也就是 ef be ad de\n以上就是所有填入内容，整合到一起：12345678123456781234567812345678D8FE190089114000efbeadde\n\n传入参数后发现得到答案\n总结  deadbeef项目要求一定的栈帧知识（有但不多），这个项目的代码量较少，操作也比较少，还是比较简单的\n\n  做完之后思考🤔 \n\n   为啥要填deadbeef 有如此神力 填个死牛肉有啥用？\n\n    DEADBEEF是一个著名的十六进制魔数（Magic Number）。虽然看起来像&quot;死牛肉&quot;的英文，但它实际上是一个特殊的调试标记值0xDEADBEEF。这个数值最早由IBM的RS/6000系统引入，用于标记已分配但未初始化的内存区域，帮助开发人员在调试时快速识别内存状态。\n\n在现代计算机系统中，DEADBEEF的使用非常广泛：\n\n操作系统应用\nMac OS（32位PowerPC）用它标记未初始化内存\nSolaris系统将其用作内核空闲内存标记\n\n\n调试场景\n嵌入式系统中用作崩溃或死锁指示器\n内存调试工具中的常用标记值\n\n\n\n这类特殊的十六进制数被称为”魔数”（Magic Number），它们在程序设计中扮演着重要角色。例如，Visual C++使用0xCC填充未初始化内存，这个值在Unicode中恰好对应中文字符”烫”，这就是为什么VC++调试时经常能看到一串”烫”字的原因。\n","categories":["SCU安全实验"],"tags":["SCU安全实验"]}]